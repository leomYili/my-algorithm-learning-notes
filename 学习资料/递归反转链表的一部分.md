# 正文

## 反转链表

首先是单链表的一个结构:

```()
// 单链表节点的结构
public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}
```

什么叫反转单链表的一部分呢，就是给你一个索引区间，让你把单链表中这部分元素反转，其他部分不变：

```()
反转从位置m到n的链表

示例:
输入: 1 -> 2 -> 3 -> 4 -> 5 -> null,m=2,n=4
输出: 1 -> 4 -> 3 -> 2 -> 5 -> null
```

注意这里的索引是从 1 开始的。迭代的思路大概是：先用一个 for 循环找到第 m 个位置，然后再用一个 for 循环将 m 和 n 之间的元素反转。但是我们的递归解法不用一个 for 循环，纯递归实现反转。

## 递归反转整个链表

```()
function reverse(head){
  if(head.next == null) return head;
  
  let last = reverse(head.next);

  head.next.next = head;
  head.next = null;

  return last;
}
```

对于递归算法,最重要的就是明确递归函数的定义.具体来说，我们的 reverse 函数定义是这样的：

输入一个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点。

虽然简单,但有两点需要注意:

1. 递归函数要有 base case，也就是这句：

    ```()
    if (head.next == null) return head;
    ```

    意思是如果链表只有一个节点的时候反转也是它自己，直接返回即可。

2. 当链表递归反转之后，新的头结点是 last，而之前的 head 变成了最后一个节点，别忘了链表的末尾要指向 null：

    ```()
    head.next = null;
    ```

## 反转链表前N个节点

这次需要实现一个这样的函数:

```()
// 将链表的前 n 个节点反转（n <= 链表长度）
function reverseN(head, n){};
```

解决思路差不多,只需要稍加修改:

```()
let successor = null; // 后驱节点

// 反转以 head 为起点的 n 个节点，返回新的头结点
function reverseN(head, n) {
    if (n == 1) { 
        // 记录第 n + 1 个节点
        successor = head.next;
        return head;
    }
    // 以 head.next 为起点，需要反转前 n - 1 个节点
    let last = reverseN(head.next, n - 1);

    head.next.next = head;
    // 让反转之后的 head 节点和后面的节点连起来
    head.next = successor;

    return last;
}
```

具体的区别:

1. base case 变为 `n == 1`,反转一个元素,就是它本身,同时要记录后驱节点.

2. 刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head.

## 反转链表的一部分

现在解决我们最开始提出的问题，给一个索引区间 [m,n]（索引从 1 开始），仅仅反转区间中的链表元素。

首先，如果 m == 1，就相当于反转链表开头的 n 个元素嘛，也就是我们刚才实现的功能：

```()
function reverseBetween(head,m,n) {
    // base case
    if (m == 1) {
        // 相当于反转前 n 个元素
        return reverseN(head, n);
    }
    // ...
}
```

如果 m != 1 怎么办？如果我们把 head 的索引视为 1，那么我们是想从第 m 个元素开始反转对吧；如果把 head.next 的索引视为 1 呢？那么相对于 head.next，反转的区间应该是从第 m - 1 个元素开始的；那么对于 head.next.next 呢……

