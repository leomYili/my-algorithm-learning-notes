# 正文

- [正文](#正文)
  - [手写深拷贝](#手写深拷贝)
    - [2021年07月27日](#2021年07月27日)
      - [为了增加熟练度,重新手写代码,第一次](#为了增加熟练度重新手写代码第一次)
      - [第二次,重新开始](#第二次重新开始)
    - [2021年07月28日](#2021年07月28日)
      - [第二次重新实现两个函数](#第二次重新实现两个函数)
  - [手写promise](#手写promise)
    - [2021年07月27日](#2021年07月27日-1)
      - [第一遍](#第一遍)
    - [2021年07月28日](#2021年07月28日-1)

> 这里是作为个人手写算法或者代码的地方,其中可能会更新比较频繁,也会不定时清空,写完之后会进行记录

## 手写深拷贝

### 2021年07月27日

#### 为了增加熟练度,重新手写代码,第一次

深拷贝主要考察的是:

1. 如何确认是否有下一层,也就是是否有对象
2. 如何解决循环引用
3. 如何破解递归暴栈

但我忽略了边界条件,没有特别记忆

同时,忘记了isObject也需要处理array的情况,所以改为`typeof`

处理循环引用,需要修改传参,这里犯了两次错误,一次记不清楚find的细节,另一次不知道target是什么

当然,递归到这里结束,然后就是循环来解决递归暴栈的问题,递归的实例中也出现了递归暴栈的情况

深拷贝中完全记不清下一步是什么,需要再次重新开始记忆

迭代与递归完全不同,要从新创建对象开始

#### 第二次,重新开始

这次基本一遍过

### 2021年07月28日

#### 第二次重新实现两个函数

递归没有问题

循环被打扰了,循环重写一次

重写时,忘记了迭代方法循环引用的返回条件不是return,而是break,且需要把target挂载在parent[key]之上,以此达到循环引用

## 手写promise

注意两点,首先是微任务队列模拟,然后是then中的链式调用,catch写不写问题不大,最好写下all与finally

### 2021年07月27日

#### 第一遍

第一遍完全忘记了resolve以及reject函数中应该需要做什么,且完全搞混了then和promise的传值,

```()
new Promise((resolve,reject) => {
  ...
});
```

然后就是promise.then, 一开始的默认参数就记不清楚了,特别是rejected的默认值

catch 也不太记得函数体了

all 也记不清了

resolve,reject完全没印象

finally 只记得第一句,还记错了,那是要在原型链 prototype 上才能使用的方法,且reject与resolve完全不一致,
reject需要抛出异常,也就是 `throw error`;

### 2021年07月28日

重新写,发现很容易忘记一些细节,resolve实现细节完全忘记

then中状态还记得,但是pending情况的代码忘记了

finally完全不对,需要记住,在写finally之前,请先写resolve与reject